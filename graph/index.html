<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Math Graph (CSP‑Safe • Live Update • Better Ticks)</title>
  <style>
    :root{ --bg:#0b1220; --panel:#0f172a; --ink:#e5e7eb; --muted:#94a3b8; --accent:#22d3ee; }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:var(--ink); font:16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans; }
    .wrap{ max-width:1000px; margin:0 auto; padding:24px; display:grid; gap:16px; }
    .card{ background:color-mix(in oklab, var(--panel) 88%, black 0%); border:1px solid #1f2937; border-radius:16px; }
    .head{ padding:10px 14px; color:var(--muted); font-size:14px; }
    textarea{ width:100%; height:120px; background:#0b1220; color:var(--ink); border:1px solid #1f2937; border-radius:12px; padding:12px; resize:vertical; }
    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    button{ background:#0f172a; color:var(--ink); border:1px solid #1f2937; padding:8px 12px; border-radius:999px; cursor:pointer; }
    button:hover{ background:#111827; }
    .accent{ background:var(--accent); color:#001018; border:none; }
    canvas{ width:100%; height:480px; display:block; }
    .muted{ color:var(--muted); font-size:14px; }
    .err{ color:#fda4af; font-size:14px; }
    .tests{ font-size:13px; white-space:pre-wrap; background:#0f172a; color:var(--ink); border:1px solid #1f2937; border-radius:12px; padding:12px; }
    details > summary{ cursor:pointer; }
    label.toggle{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #1f2937; border-radius:999px; background:#0f172a; }
  </style>
</head>
<body>
<div class="wrap">
  <h1 style="margin:0; font-size:22px;">Web Math Graph — CSP‑Safe (no eval)</h1>

  <div class="card" style="padding:16px; display:grid; gap:10px;">
    <label class="muted">Functions (one per line). Use <code>x</code>, <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>log</code> (<em>ln</em> alias), <code>exp</code>, <code>sqrt</code>, constants <code>PI</code>, <code>E</code>. Powers: <code>^</code>. Examples: <code>x^2</code>, <code>sin(x)</code>, <code>x^3-3*x</code>.</label>
    <textarea id="fx">x^2
sin(x)</textarea>
    <div class="row">
      <span class="muted">Scale</span>
      <input id="scale" type="range" min="5" max="2000" value="40" />
      <span id="scaleLabel" class="muted">40 px/unit</span>
      <button id="resetFns">Reset to y=x^2</button>
      <button id="addSin" class="accent">+ Add sin(x)</button>
      <button id="resetView">Reset View</button>
      <button id="runTests">Run self‑tests</button>
      <label class="toggle"><input type="checkbox" id="autoUpdate" checked /> Auto update</label>
      <button id="renderNow">Update now</button>
    </div>
    <div id="err" class="err"></div>
  </div>

  <div class="card">
    <div class="head">Pan: drag • Zoom: mouse wheel</div>
    <canvas id="c"></canvas>
  </div>

  <details class="card" open>
    <summary class="head">Parser self‑tests</summary>
    <div id="testlog" class="tests">(not run yet)</div>
  </details>
</div>

<script type="module">
  // --- Tiny CSP‑safe math parser: shunting‑yard to RPN, then evaluate ---
  const OPS = {
    '+': {p:1, a:'L', f:(a,b)=>a+b},
    '-': {p:1, a:'L', f:(a,b)=>a-b},
    '*': {p:2, a:'L', f:(a,b)=>a*b},
    '/': {p:2, a:'L', f:(a,b)=>a/b},
    '^': {p:3, a:'R', f:(a,b)=>Math.pow(a,b)},
  };
  const FUN = {
    sin: Math.sin, cos: Math.cos, tan: Math.tan,
    log: Math.log, ln: Math.log, exp: Math.exp, sqrt: Math.sqrt, abs: Math.abs,
    asin: Math.asin, acos: Math.acos, atan: Math.atan,
    floor: Math.floor, ceil: Math.ceil, round: Math.round
  };
  const CONSTS = { PI: Math.PI, E: Math.E };

  function tokenize(s){
    const tokens=[]; let i=0; s=s.replaceAll(' ','').replaceAll('\t','');
    const isNum=c=>/[0-9.]/.test(c);
    const isAlpha=c=>/[a-zA-Z_]/.test(c);
    while(i<s.length){
      const c=s[i];
      if(isNum(c)){
        let j=i+1; while(j<s.length && isNum(s[j])) j++;
        tokens.push({type:'num', v:parseFloat(s.slice(i,j))}); i=j; continue;
      }
      if(isAlpha(c)){
        let j=i+1; while(j<s.length && /[a-zA-Z0-9_]/.test(s[j])) j++;
        const name=s.slice(i,j);
        if(name==='x') tokens.push({type:'var'});
        else if(FUN[name]) tokens.push({type:'fun', v:name});
        else if(CONSTS[name]!==undefined) tokens.push({type:'num', v:CONSTS[name]});
        else throw new Error('Unknown token: '+name);
        i=j; continue;
      }
      if('+-*/^(),'.includes(c)){
        tokens.push({type:c}); i++; continue;
      }
      throw new Error('Bad character: '+c);
    }
    return tokens;
  }

  function toRPN(tokens){
    const out=[]; const stack=[]; let prev=null;
    for(const t of tokens){
      if(t.type==='num' || t.type==='var') out.push(t);
      else if(t.type==='fun') stack.push(t);
      else if(t.type===','){
        while(stack.length && stack[stack.length-1].type!=='(') out.push(stack.pop());
        if(!stack.length) throw new Error('Unexpected comma');
      }
      else if(t.type in OPS){
        // unary minus -> convert to (0 - expr)
        if(t.type==='-' && (prev==null || (prev.type in OPS) || prev.type==='(' || prev.type===',')){
          out.push({type:'num', v:0});
        }
        while(stack.length){
          const top=stack[stack.length-1];
          if(!(top.type in OPS)) break;
          const o1=OPS[t.type], o2=OPS[top.type];
          if((o1.a==='L' && o1.p<=o2.p) || (o1.a==='R' && o1.p<o2.p)) out.push(stack.pop()); else break;
        }
        stack.push(t);
      }
      else if(t.type==='('){ stack.push(t); }
      else if(t.type===')'){
        while(stack.length && stack[stack.length-1].type!=='(') out.push(stack.pop());
        if(!stack.length) throw new Error('Unmatched )');
        stack.pop();
        if(stack.length && stack[stack.length-1].type==='fun') out.push(stack.pop());
      }
      prev=t;
    }
    while(stack.length){
      const t=stack.pop(); if(t.type==='('||t.type===')') throw new Error('Unmatched ('); out.push(t);
    }
    return out;
  }

  function compile(expr){
    const rpn = toRPN(tokenize(expr));
    return function(x){
      const st=[];
      for(const t of rpn){
        if(t.type==='num') st.push(t.v);
        else if(t.type==='var') st.push(x);
        else if(t.type in OPS){ const b=st.pop(), a=st.pop(); st.push(OPS[t.type].f(a,b)); }
        else if(t.type==='fun'){ const a=st.pop(); st.push(FUN[t.v](a)); }
        else throw new Error('Bad RPN token');
      }
      if(st.length!==1) throw new Error('Eval error');
      return st[0];
    }
  }

  // --- UI + plotting (using compile()) ---
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const fxArea = document.getElementById('fx');
  const scaleInput = document.getElementById('scale');
  const scaleLabel = document.getElementById('scaleLabel');
  const errEl = document.getElementById('err');
  const autoUpdate = document.getElementById('autoUpdate');

  let scale = 40; // px per unit
  let origin = { x: 0, y: 0 };
  let dragging = false; let dragStart = { x:0, y:0, ox:0, oy:0 };

  function niceStep(target){
    const exp = Math.floor(Math.log10(target));
    const base = target / 10 ** exp;
    let nice = base >= 5 ? 5 : base >= 2 ? 2 : 1;
    return nice * 10 ** exp;
  }

  function formatTick(value, step){
    // Determine decimals based on step size; cap to 8 decimals
    const d = Math.max(0, Math.min(8, -Math.floor(Math.log10(step))+1));
    const s = value.toFixed(d);
    return s.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
  }

  function drawGridAxes(w,h){
    ctx.lineWidth = 1;
    // grid
    ctx.strokeStyle = '#1f2937';
    const xStep = niceStep(w/scale/10);
    for(let x = Math.ceil(-origin.x/scale/xStep)*xStep; x < (w-origin.x)/scale; x+=xStep){
      const sx = origin.x + x*scale; ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,h); ctx.stroke();
    }
    const yStep = niceStep(h/scale/10);
    for(let y = Math.ceil((origin.y-h)/scale/yStep)*yStep; y < origin.y/scale; y+=yStep){
      const sy = origin.y - y*scale; ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(w,sy); ctx.stroke();
    }
    // axes
    ctx.strokeStyle = '#94a3b8';
    ctx.beginPath(); ctx.moveTo(0,origin.y); ctx.lineTo(w,origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x,0); ctx.lineTo(origin.x,h); ctx.stroke();
    // tick labels (rounded)
    ctx.fillStyle = '#94a3b8'; ctx.font = '12px system-ui';
    const xStepL = xStep, yStepL = yStep;
    for(let x = Math.ceil(-origin.x/scale/xStepL)*xStepL; x < (w-origin.x)/scale; x+=xStepL){
      if (Math.abs(x) < 1e-9) continue; const sx = origin.x + x*scale; ctx.fillText(formatTick(x, xStepL), sx+2, origin.y+12);
    }
    for(let y = Math.ceil((origin.y-h)/scale/yStepL)*yStepL; y < origin.y/scale; y+=yStepL){
      if (Math.abs(y) < 1e-9) continue; const sy = origin.y - y*scale; ctx.fillText(formatTick(y, yStepL), origin.x+6, sy-2);
    }
  }

  function plot(fn, w, h, color){
    ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.beginPath();
    const step = 1/scale; let first=true;
    const xMin = -origin.x/scale, xMax = (w-origin.x)/scale;
    for(let x=xMin; x<=xMax; x+=step){
      let y = fn(x); if(!Number.isFinite(y)){ first=true; continue; }
      const sx = origin.x + x*scale; const sy = origin.y - y*scale;
      if(first){ ctx.moveTo(sx,sy); first=false; } else { ctx.lineTo(sx,sy); }
    }
    ctx.stroke();
  }

  function render(){
    const dpr = window.devicePixelRatio || 1;
    const w = c.clientWidth * dpr, h = c.clientHeight * dpr;
    if (c.width!==w || c.height!==h){ c.width=w; c.height=h; }
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,w,h);
    drawGridAxes(w,h);
    errEl.textContent = '';
    const lines = fxArea.value.split('\n').map(s=>s.trim()).filter(Boolean);
    const hues = [190,160,120,60,20,300,260,0];
    lines.forEach((line,i)=>{
      try{ const fn = compile(line.replaceAll('−','-')); if(!fn) return;
        const color = `hsl(${hues[i%hues.length]} 80% 60%)`;
        plot(fn, w, h, color);
      }catch(e){ errEl.textContent = String(e.message||e); }
    });
  }

  // center origin initially
  function centerOrigin(){
    const dpr = window.devicePixelRatio || 1;
    origin.x = (c.clientWidth * dpr)/2; origin.y = (c.clientHeight * dpr)/2;
  }
  centerOrigin();

  // UI bindings
  scaleInput.addEventListener('input', ()=>{
    scale = parseInt(scaleInput.value,10);
    scaleLabel.textContent = scale+' px/unit';
    render();
  });
  document.getElementById('resetFns').addEventListener('click', ()=>{ fxArea.value = 'x^2'; render(); });
  document.getElementById('addSin').addEventListener('click', ()=>{ fxArea.value += (fxArea.value.endsWith('\n')?'':'\n') + 'sin(x)'; render(); });
  document.getElementById('resetView').addEventListener('click', ()=>{ scale=40; scaleInput.value='40'; scaleLabel.textContent='40 px/unit'; centerOrigin(); render(); });
  document.getElementById('renderNow').addEventListener('click', render);

  // live update toggle
  fxArea.addEventListener('input', ()=>{ if(autoUpdate.checked) render(); });

  // interactions
  c.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const s = Math.sign(e.deltaY);
    const prev=scale;
    // extended zoom range
    scale = Math.min(2000, Math.max(5, scale * (s>0?0.9:1.1)));
    if(scale!==prev){ scaleInput.value=String(Math.round(scale)); scaleLabel.textContent=scale+' px/unit'; render(); }
  }, {passive:false});
  c.addEventListener('mousedown', (e)=>{ dragging=true; dragStart={ x:e.clientX, y:e.clientY, ox:origin.x, oy:origin.y }; });
  window.addEventListener('mousemove', (e)=>{ if(!dragging) return; const dpr=window.devicePixelRatio||1; origin.x = dragStart.ox + (e.clientX-dragStart.x)*dpr; origin.y = dragStart.oy + (e.clientY-dragStart.y)*dpr; render(); });
  window.addEventListener('mouseup', ()=>{ dragging=false; });

  // resize-aware
  const ro = new ResizeObserver(()=>render()); ro.observe(c);

  // --- Self tests ---
  const testlog = document.getElementById('testlog');
  document.getElementById('runTests').addEventListener('click', runTests);

  function approx(a,b,eps=1e-9){ return Math.abs(a-b) <= eps; }
  function line(msg, ok){ return `${ok?'✅':'❌'} ${msg}`; }

  function runTests(){
    const tests = [];
    try{
      const f1 = compile('x^2'); tests.push(line('x^2 at x=3 => 9', approx(f1(3),9)));
      const f2 = compile('sin(x)'); tests.push(line('sin(0) => 0', approx(f2(0),0)));
      const f3 = compile('x^3-3*x'); tests.push(line('x^3-3*x at x=2 => 2', approx(f3(2),2)));
      const f4 = compile('sqrt(abs(x))'); tests.push(line('sqrt(abs(-9)) => 3', approx(f4(-9),3)));
      const f5 = compile('exp(-x^2)'); tests.push(line('exp(-x^2) at x=0 => 1', approx(f5(0),1)));
      const f6 = compile('log(E)'); tests.push(line('log(E) => 1', approx(f6(0),1)));
      const f7 = compile('-x'); tests.push(line('unary minus: -x at x=5 => -5', approx(f7(5),-5)));
      const f8 = compile('sin(PI/2)'); tests.push(line('sin(PI/2) => 1', approx(f8(0),1)));
      const f9 = compile('ln(E^2)'); tests.push(line('ln(E^2) => 2', approx(f9(0),2)));

      testlog.textContent = `${tests.join('\n')}\n\n${tests.every(t=>t.startsWith('✅'))?'All passed.':'Some failed.'}`;
    }catch(e){ testlog.textContent = 'Test crashed: '+(e?.message||e); }
  }

  // initial render + tests
  render();
  runTests();
</script>
</body>
</html>
