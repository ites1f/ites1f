<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Graph Calc</title>
  <style>
    /* Pure monochrome theme */
    :root{
      --bg:#0a0a0a;        --panel:#141414;  --ink:#e6e6e6;
      --muted:#a3a3a3;     --border:#2a2a2a; --ctl:#0f0f0f; --ctl-hover:#1a1a1a;
    }
    *{ box-sizing:border-box; } html, body { height:100%; }
    body{ margin:0; background:var(--bg); color:var(--ink); font:16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans; }

    /* Fullscreen canvas */
    #stage { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    canvas#c { width: 100%; height: 100%; display: block; }

    /* Compact control panel (~1/16 screen, bottom-left) */
    .panel {
      position: fixed; left: 16px; bottom: 16px; right: auto;
      width: min(360px, 24vw); max-width: 92vw;
      background: var(--panel);
      border: 1px solid var(--border); border-radius: 14px; padding: 12px;
      display: grid; gap: 8px; box-shadow: 0 6px 24px rgba(0,0,0,.35);
      backdrop-filter: blur(2px);
    }
    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .muted{ color:var(--muted); font-size:12px; }
    textarea{
      width:100%; height:96px;
      background:var(--ctl); color:var(--ink);
      border:1px solid var(--border); border-radius:10px; padding:10px; resize:vertical;
    }
    input[type="range"]{ width: 160px; }
    button{
      background:var(--ctl); color:var(--ink);
      border:1px solid var(--border); padding:6px 10px;
      border-radius:999px; cursor:pointer; font-size:13px;
    }
    button:hover{ background:var(--ctl-hover); }
    label.toggle{
      display:inline-flex; align-items:center; gap:6px; padding:4px 8px;
      border:1px solid var(--border); border-radius:999px; background:var(--ctl);
    }
    .err{ color:#d4d4d4; font-size:13px; min-height: 1.2em; }

    details > summary{ cursor:pointer; color:var(--muted); font-size:12px; }
    .tests{
      font-size:12px; white-space:pre-wrap;
      background:var(--panel); color:var(--ink); border:1px solid var(--border);
      border-radius:10px; padding:10px;
    }
  </style>
</head>
<body>

  <div id="stage"><canvas id="c"></canvas></div>

  <!-- Compact control panel -->
  <div class="panel" role="region" aria-label="Graph Controls">
    <div class="muted">
      Functions (one per line). Use <code>x</code>, <code>a</code> (parameter), <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>log/ln</code>, <code>exp</code>, <code>sqrt</code>, <code>PI</code>, <code>E</code>. Powers: <code>^</code>.
    </div>
    <textarea id="fx" placeholder="e.g. a*sin(x)\n(x^2) + a*x"></textarea>

    <!-- Parameter a -->
    <div class="row">
      <span class="muted">a</span>
      <input id="paramA" type="range" min="-10" max="10" value="1" step="0.1" />
      <span id="paramALabel" class="muted">1.0</span>
    </div>

    <!-- Scale -->
    <div class="row">
      <span class="muted">Scale</span>
      <input id="scale" type="range" min="5" max="2000" value="40" step="1" />
      <span id="scaleLabel" class="muted">40 px/unit</span>
    </div>

    <!-- Points -->
    <div class="muted">Points (one per line, formats: <code>x,y</code> or <code>(x,y)</code>)</div>
    <textarea id="points" placeholder="e.g.\n1,2\n-3,0.5"></textarea>
    <div class="row">
      <label class="toggle"><input type="checkbox" id="clickAdd" /> Click to add points</label>
      <button id="clearPts">Clear points</button>
    </div>

    <div class="row">
      <button id="resetFns">Clear functions</button>
      <button id="resetView">Reset view</button>
      <label class="toggle"><input type="checkbox" id="autoUpdate" checked /> Auto update</label>
    </div>

    <div id="err" class="err"></div>

    <details>
      <summary>Parser self-tests</summary>
      <div id="testlog" class="tests">(not run yet)</div>
      <div class="row" style="margin-top:6px;">
        <button id="runTests">Run tests</button>
      </div>
    </details>
  </div>

<script type="module">
  // --- CSP-safe math parser (shunting-yard -> RPN -> eval) ---
  const OPS = {
    '+': {p:1, a:'L', f:(a,b)=>a+b},
    '-': {p:1, a:'L', f:(a,b)=>a-b},
    '*': {p:2, a:'L', f:(a,b)=>a*b},
    '/': {p:2, a:'L', f:(a,b)=>a/b},
    '^': {p:3, a:'R', f:(a,b)=>Math.pow(a,b)},
  };
  const FUN = {
    sin: Math.sin, cos: Math.cos, tan: Math.tan,
    log: Math.log, ln: Math.log, exp: Math.exp, sqrt: Math.sqrt, abs: Math.abs,
    asin: Math.asin, acos: Math.acos, atan: Math.atan,
    floor: Math.floor, ceil: Math.ceil, round: Math.round
  };
  const CONSTS = { PI: Math.PI, E: Math.E };

  function tokenize(s){
    const tokens=[]; let i=0; s=s.replaceAll(' ','').replaceAll('\\t','');
    const isNum=c=>/[0-9.]/.test(c);
    const isAlpha=c=>/[a-zA-Z_]/.test(c);
    while(i<s.length){
      const c=s[i];
      if(isNum(c)){
        let j=i+1; while(j<s.length && isNum(s[j])) j++;
        tokens.push({type:'num', v:parseFloat(s.slice(i,j))}); i=j; continue;
      }
      if(isAlpha(c)){
        let j=i+1; while(j<s.length && /[a-zA-Z0-9_]/.test(s[j])) j++;
        const name=s.slice(i,j);
        if(name==='x') tokens.push({type:'var', v:'x'});
        else if(name==='a') tokens.push({type:'var', v:'a'});        // allow 'a' as a variable token
        else if(FUN[name]) tokens.push({type:'fun', v:name});
        else if(CONSTS[name]!==undefined) tokens.push({type:'num', v:CONSTS[name]});
        else throw new Error('Unknown token: '+name);
        i=j; continue;
      }
      if('+-*/^(),'.includes(c)){ tokens.push({type:c}); i++; continue; }
      throw new Error('Bad character: '+c);
    }
    return tokens;
  }

  function toRPN(tokens){
    const out=[]; const stack=[]; let prev=null;
    for(const t of tokens){
      if(t.type==='num' || t.type==='var') out.push(t);
      else if(t.type==='fun') stack.push(t);
      else if(t.type===','){
        while(stack.length && stack[stack.length-1].type!=='(') out.push(stack.pop());
        if(!stack.length) throw new Error('Unexpected comma');
      }
      else if(t.type in OPS){
        // unary minus -> (0 - expr)
        if(t.type==='-' && (prev==null || (prev.type in OPS) || prev.type==='(' || prev.type===',')){
          out.push({type:'num', v:0});
        }
        while(stack.length){
          const top=stack[stack.length-1];
          if(!(top.type in OPS)) break;
          const o1=OPS[t.type], o2=OPS[top.type];
          if((o1.a==='L' && o1.p<=o2.p) || (o1.a==='R' && o1.p<o2.p)) out.push(stack.pop()); else break;
        }
        stack.push(t);
      }
      else if(t.type==='('){ stack.push(t); }
      else if(t.type===')'){
        while(stack.length && stack[stack.length-1].type!=='(') out.push(stack.pop());
        if(!stack.length) throw new Error('Unmatched )');
        stack.pop();
        if(stack.length && stack[stack.length-1].type==='fun') out.push(stack.pop());
      }
      prev=t;
    }
    while(stack.length){
      const t=stack.pop(); if(t.type==='('||t.type===')') throw new Error('Unmatched ('); out.push(t);
    }
    return out;
  }

  // compile now returns a function of (x, env) so we can pass a
  function compile(expr){
    const rpn = toRPN(tokenize(expr));
    return function(x, env){
      const st=[];
      for(const t of rpn){
        if(t.type==='num') st.push(t.v);
        else if(t.type==='var'){
          if(t.v==='x') st.push(x);
          else if(t.v==='a') st.push(env?.a ?? 0);  // default a=0 if missing
          else throw new Error('Unknown variable: '+t.v);
        }
        else if(t.type in OPS){ const b=st.pop(), a=st.pop(); st.push(OPS[t.type].f(a,b)); }
        else if(t.type==='fun'){ const a=st.pop(); st.push(FUN[t.v](a)); }
        else throw new Error('Bad RPN token');
      }
      if(st.length!==1) throw new Error('Eval error');
      return st[0];
    }
  }

  // --- UI + plotting ---
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const fxArea = document.getElementById('fx');
  const scaleInput = document.getElementById('scale');
  const scaleLabel = document.getElementById('scaleLabel');
  const errEl = document.getElementById('err');
  const autoUpdate = document.getElementById('autoUpdate');
  const runBtn = document.getElementById('runTests');
  const testlog = document.getElementById('testlog');
  const paramA = document.getElementById('paramA');
  const paramALabel = document.getElementById('paramALabel');
  const pointsArea = document.getElementById('points');
  const clickAdd = document.getElementById('clickAdd');
  const clearPts = document.getElementById('clearPts');

  let scale = 40;            // px per unit (same for X and Y)
  let origin = { x: 0, y: 0 };
  let dragging = false; let dragStart = { x:0, y:0, ox:0, oy:0 };

  function niceStep(target){
    const exp = Math.floor(Math.log10(target));
    const base = target / 10 ** exp;
    let nice = base >= 5 ? 5 : base >= 2 ? 2 : 1;
    return nice * 10 ** exp;
  }
  function formatTick(value, step){
    const d = Math.max(0, Math.min(8, -Math.floor(Math.log10(step))+1));
    let s = value.toFixed(d);
    if (s.includes('.')) { s = s.replace(/0+$/, ''); if (s.endsWith('.')) s = s.slice(0,-1); }
    return s;
  }

  function drawGridAxes(w,h){
    ctx.lineWidth = 1;

    // ONE common world step → square grid cells
    const xSpan = w / scale, ySpan = h / scale;
    const step  = niceStep(Math.min(xSpan, ySpan) / 10);

    // Grid (pure gray)
    ctx.strokeStyle = '#1a1a1a';
    for (let x = Math.ceil(-origin.x/scale/step)*step; x < (w-origin.x)/scale; x += step) {
      const sx = origin.x + x*scale; ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, h); ctx.stroke();
    }
    for (let y = Math.ceil((origin.y-h)/scale/step)*step; y < origin.y/scale; y += step) {
      const sy = origin.y - y*scale; ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(w, sy); ctx.stroke();
    }

    // Axes (slightly brighter)
    ctx.strokeStyle = '#6b6b6b';
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h); ctx.stroke();

    // Tick labels (gray)
    ctx.fillStyle = '#a3a3a3'; ctx.font = '12px system-ui';
    for (let x = Math.ceil(-origin.x/scale/step)*step; x < (w-origin.x)/scale; x += step) {
      if (Math.abs(x) < 1e-9) continue; const sx = origin.x + x*scale; ctx.fillText(formatTick(x, step), sx+2, origin.y+12);
    }
    for (let y = Math.ceil((origin.y-h)/scale/step)*step; y < origin.y/scale; y += step) {
      if (Math.abs(y) < 1e-9) continue; const sy = origin.y - y*scale; ctx.fillText(formatTick(y, step), origin.x+6, sy-2);
    }
  }

  function plot(fn, w, h, color, env){
    ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.beginPath();
    const step = 1/scale; let first=true;
    const xMin = -origin.x/scale, xMax = (w-origin.x)/scale;
    for(let x=xMin; x<=xMax; x+=step){
      let y = fn(x, env); if(!Number.isFinite(y)){ first=true; continue; }
      const sx = origin.x + x*scale; const sy = origin.y - y*scale;
      if(first){ ctx.moveTo(sx,sy); first=false; } else { ctx.lineTo(sx,sy); }
    }
    ctx.stroke();
  }

  function parsePoints(text){
    const pts=[];
    const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
    for(const line of lines){
      // Accept: "x,y" OR "(x,y)" OR "x y"
      const m = line.match(/^\(?\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*[, ]\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*\)?$/i);
      if(m){
        pts.push({x:parseFloat(m[1]), y:parseFloat(m[2])});
      }
    }
    return pts;
  }

  function drawPoints(w,h, pts){
    ctx.lineWidth = 1.5;
    for(const p of pts){
      const sx = origin.x + p.x*scale;
      const sy = origin.y - p.y*scale;
      // small circle
      ctx.beginPath();
      ctx.arc(sx, sy, Math.max(2, 4), 0, Math.PI*2);
      ctx.fillStyle = '#e6e6e6';
      ctx.strokeStyle = '#6b6b6b';
      ctx.fill(); ctx.stroke();
    }
  }

  function render(){
    const dpr = window.devicePixelRatio || 1;
    const w = c.clientWidth * dpr, h = c.clientHeight * dpr;
    if (c.width!==w || c.height!==h){ c.width=w; c.height=h; }

    // Background
    ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,w,h);

    // Grid & axes
    drawGridAxes(w,h);

    // Functions — rainbow (comma-style HSL for canvas compatibility)
    errEl.textContent = '';
    const aVal = parseFloat(paramA.value);
    const env = { a: aVal };
    const lines = fxArea.value.split('\n').map(s=>s.trim()).filter(Boolean);
    const hues = [0,30,60,120,180,210,240,270,300];
    lines.forEach((line,i)=>{
      try{
        const fn = compile(line.replaceAll('−','-')); if(!fn) return;
        const color = `hsl(${hues[i % hues.length]}, 75%, 55%)`;
        plot(fn, w, h, color, env);
      }catch(e){ errEl.textContent = String(e.message||e); }
    });

    // Points
    const pts = parsePoints(pointsArea.value);
    drawPoints(w,h, pts);
  }

  // center origin initially
  function centerOrigin(){
    const dpr = window.devicePixelRatio || 1;
    origin.x = (c.clientWidth * dpr)/2; origin.y = (c.clientHeight * dpr)/2;
  }
  centerOrigin();

  // UI bindings
  scaleInput.addEventListener('input', ()=>{
    scale = parseInt(scaleInput.value,10);
    scaleLabel.textContent = scale+' px/unit';
    render();
  });

  // parameter a
  paramA.addEventListener('input', ()=>{
    paramALabel.textContent = parseFloat(paramA.value).toFixed(1);
    if(autoUpdate.checked) render();
  });

  document.getElementById('resetFns').addEventListener('click', ()=>{
    fxArea.value = ''; render();
  });
  document.getElementById('resetView').addEventListener('click', ()=>{
    scale=40; scaleInput.value='40'; scaleLabel.textContent='40 px/unit'; centerOrigin(); render();
  });

  // Points: clear, and click-to-add
  clearPts.addEventListener('click', ()=>{ pointsArea.value=''; render(); });

  c.addEventListener('click', (e)=>{
    if(!clickAdd.checked) return;
    // Convert screen → world
    const rect = c.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const sx = (e.clientX - rect.left) * dpr;
    const sy = (e.clientY - rect.top) * dpr;
    const x = (sx - origin.x) / scale;
    const y = (origin.y - sy) / scale;
    const line = `${x.toFixed(3)},${y.toFixed(3)}`;
    pointsArea.value += (pointsArea.value.trim() ? '\n' : '') + line;
    render();
  });

  // live update when typing
  fxArea.addEventListener('input', ()=>{ if(autoUpdate.checked) render(); });
  pointsArea.addEventListener('input', ()=>{ if(autoUpdate.checked) render(); });

  // interactions
  c.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const s = Math.sign(e.deltaY);
    const prev=scale;
    scale = Math.min(2000, Math.max(5, Math.round(scale * (s>0?0.9:1.1))));
    if(scale!==prev){ scaleInput.value=String(scale); scaleLabel.textContent=scale+' px/unit'; render(); }
  }, {passive:false});
  c.addEventListener('mousedown', (e)=>{ dragging=true; dragStart={ x:e.clientX, y:e.clientY, ox:origin.x, oy:origin.y }; });
  window.addEventListener('mousemove', (e)=>{ if(!dragging) return; const dpr=window.devicePixelRatio||1; origin.x = dragStart.ox + (e.clientX-dragStart.x)*dpr; origin.y = dragStart.oy + (e.clientY-dragStart.y)*dpr; render(); });
  window.addEventListener('mouseup', ()=>{ dragging=false; });

  // resize-aware
  const ro = new ResizeObserver(()=>render()); ro.observe(c);

  // --- Self tests (unchanged) ---
  runBtn.addEventListener('click', runTests);
  function approx(a,b,eps=1e-9){ return Math.abs(a-b) <= eps; }
  function line(msg, ok){ return `${ok?'✅':'❌'} ${msg}`; }
  function runTests(){
    const tests = [];
    try{
      const f1 = compile('x^2'); tests.push(line('x^2 at x=3 => 9', approx(f1(3),9)));
      const f2 = compile('sin(x)'); tests.push(line('sin(0) => 0', approx(f2(0),0)));
      const f3 = compile('x^3-3*x'); tests.push(line('x^3-3*x at x=2 => 2', approx(f3(2),2)));
      const f4 = compile('sqrt(abs(x))'); tests.push(line('sqrt(abs(-9)) => 3', approx(f4(-9),3)));
      const f5 = compile('exp(-x^2)'); tests.push(line('exp(-x^2) at x=0 => 1', approx(f5(0),1)));
      const f6 = compile('log(E)'); tests.push(line('log(E) => 1', approx(f6(0),1)));
      const f7 = compile('-x'); tests.push(line('unary minus: -x at x=5 => -5', approx(f7(5),-5)));
      const f8 = compile('sin(PI/2)'); tests.push(line('sin(PI/2) => 1', approx(f8(0),1)));
      const f9 = compile('ln(E^2)'); tests.push(line('ln(E^2) => 2', approx(f9(0),2)));

      testlog.textContent = `${tests.join('\n')}\n\n${tests.every(t=>t.startsWith('✅'))?'All passed.':'Some failed.'}`;
    }catch(e){ testlog.textContent = 'Test crashed: '+(e?.message||e); }
  }

  // initial paint (blank)
  render();
</script>
</body>
</html>
