<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Graph Calc</title>
  <style>
    /* Pure monochrome theme */
    :root{
      --bg:#0a0a0a;        --panel:#141414;  --ink:#e6e6e6;
      --muted:#a3a3a3;     --border:#2a2a2a; --ctl:#0f0f0f; --ctl-hover:#1a1a1a;
    }
    *{ box-sizing:border-box; } html, body { height:100%; }
    body{ margin:0; background:var(--bg); color:var(--ink);
      font:16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans; }

    /* Fullscreen canvas */
    #stage { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    canvas#c { width: 100%; height: 100%; display: block; }

    /* Left control panel (~1/16 screen, bottom-left) */
    .panel {
      position: fixed; left: 16px; bottom: 16px; right: auto;
      width: min(360px, 24vw); max-width: 92vw;
      background: var(--panel);
      border: 1px solid var(--border); border-radius: 14px; padding: 12px;
      display: grid; gap: 8px; box-shadow: 0 6px 24px rgba(0,0,0,.35);
      backdrop-filter: blur(2px);
    }
    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .muted{ color:var(--muted); font-size:12px; }
    textarea{
      width:100%; height:140px;
      background:var(--ctl); color:var(--ink);
      border:1px solid var(--border); border-radius:10px; padding:10px; resize:vertical;
    }
    input[type="range"]{ width: 160px; }
    button{
      background:var(--ctl); color:var(--ink);
      border:1px solid var(--border); padding:6px 10px;
      border-radius:999px; cursor:pointer; font-size:13px;
    }
    button:hover{ background:var(--ctl-hover); }
    label.toggle{
      display:inline-flex; align-items:center; gap:6px; padding:4px 8px;
      border:1px solid var(--border); border-radius:999px; background:var(--ctl);
    }
    .err{ color:#d4d4d4; font-size:13px; min-height: 1.2em; white-space: pre-wrap; }
    details > summary{ cursor:pointer; color:var(--muted); font-size:12px; }
    .tests{
      font-size:12px; white-space:pre-wrap;
      background:var(--panel); color:var(--ink); border:1px solid var(--border);
      border-radius:10px; padding:10px;
    }

    /* Right variable sliders panel */
    .varpanel{
      position: fixed; right: 16px; top: 16px; bottom: auto;
      width: min(320px, 22vw); max-width: 92vw;
      background: var(--panel);
      border: 1px solid var(--border); border-radius: 14px; padding: 12px;
      display: grid; gap: 10px; box-shadow: 0 6px 24px rgba(0,0,0,.35);
    }
    .varRow{
      display:grid; grid-template-columns: 1fr auto; gap: 6px; align-items:center;
    }
    .varRow label{
      display:flex; gap:8px; align-items:center; color:var(--ink); font-size:13px;
    }
    .varRow small{ color:var(--muted); }
    .varRow input[type="range"]{ width:100%; }
  </style>
</head>
<body>

  <div id="stage"><canvas id="c"></canvas></div>

  <!-- Left: main controls -->
  <div class="panel" role="region" aria-label="Graph Controls">
    <div class="muted">
      One box for everything: <b>variables</b> (<code>a = 16</code>), <b>points</b> (<code>(1,2)</code> or <code>1,2</code>),
      and <b>functions of x</b> (<code>a*sin(x)</code>, <code>x^2 + b*x</code>). Powers: <code>^</code>. Built-ins:
      <code>sin, cos, tan, log/ln, exp, sqrt, abs, floor, ceil, round, PI, E</code>.
      <br>Variables automatically get <b>sliders on the right</b>.
    </div>
    <textarea id="fx" placeholder="Examples:
a = 1.5
b = -2
a*sin(x)
x^2 + b*x
(1, 2.5)
-3, 0.5"></textarea>

    <div class="row">
      <span class="muted">Scale</span>
      <input id="scale" type="range" min="5" max="2000" value="40" step="1" />
      <span id="scaleLabel" class="muted">40 px/unit</span>
    </div>

    <div class="row">
      <label class="toggle"><input type="checkbox" id="clickAdd" /> Click canvas to add (x,y)</label>
    </div>

    <div class="row">
      <button id="resetFns">Clear box</button>
      <button id="resetView">Reset view</button>
      <label class="toggle"><input type="checkbox" id="autoUpdate" checked /> Auto update</label>
    </div>

    <div id="err" class="err"></div>

    <details>
      <summary>Parser self-tests</summary>
      <div id="testlog" class="tests">(not run yet)</div>
      <div class="row" style="margin-top:6px;">
        <button id="runTests">Run tests</button>
      </div>
    </details>
  </div>

  <!-- Right: dynamic variable sliders -->
  <div id="varPanel" class="varpanel" role="region" aria-label="Variable Sliders" hidden>
    <div class="muted">Variables</div>
    <div id="varList"></div>
  </div>

<script type="module">
  // === Utilities (robustness) ===
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  function toFiniteNumber(x, fallback){
    const n = Number(x);
    return Number.isFinite(n) ? n : fallback;
  }

  // --- CSP-safe math parser (shunting-yard -> RPN -> eval) ---
  const OPS = {
    '+': {p:1, a:'L', f:(a,b)=>a+b},
    '-': {p:1, a:'L', f:(a,b)=>a-b},
    '*': {p:2, a:'L', f:(a,b)=>a*b},
    '/': {p:2, a:'L', f:(a,b)=>a/b},
    '^': {p:3, a:'R', f:(a,b)=>Math.pow(a,b)},
  };
  const FUN = {
    sin: Math.sin, cos: Math.cos, tan: Math.tan,
    log: Math.log, ln: Math.log, exp: Math.exp, sqrt: Math.sqrt, abs: Math.abs,
    asin: Math.asin, acos: Math.acos, atan: Math.atan,
    floor: Math.floor, ceil: Math.ceil, round: Math.round
  };
  const CONSTS = { PI: Math.PI, E: Math.E };

  function tokenize(s){
    const tokens=[]; let i=0; s=s.replaceAll(' ','').replaceAll('\\t','');
    const isNum=c=>/[0-9.]/.test(c);
    const isAlpha=c=>/[a-zA-Z_]/.test(c);
    while(i<s.length){
      const c=s[i];
      if(isNum(c)){
        let j=i+1; while(j<s.length && isNum(s[j])) j++;
        tokens.push({type:'num', v:parseFloat(s.slice(i,j))}); i=j; continue;
      }
      if(isAlpha(c)){
        let j=i+1; while(j<s.length && /[a-zA-Z0-9_]/.test(s[j])) j++;
        const name=s.slice(i,j);
        if(name==='x') tokens.push({type:'var', v:'x'});
        else if(FUN[name]) tokens.push({type:'fun', v:name});
        else if(CONSTS[name]!==undefined) tokens.push({type:'num', v:CONSTS[name]});
        else tokens.push({type:'var', v:name}); // generic variable name
        i=j; continue;
      }
      if('+-*/^(),'.includes(c)){ tokens.push({type:c}); i++; continue; }
      throw new Error('Bad character: '+c);
    }
    return tokens;
  }

  function toRPN(tokens){
    const out=[]; const stack=[]; let prev=null;
    for(const t of tokens){
      if(t.type==='num' || t.type==='var') out.push(t);
      else if(t.type==='fun') stack.push(t);
      else if(t.type===','){
        while(stack.length && stack[stack.length-1].type!=='(') out.push(stack.pop());
        if(!stack.length) throw new Error('Unexpected comma');
      }
      else if(t.type in OPS){
        if(t.type==='-' && (prev==null || (prev.type in OPS) || prev.type==='(' || prev.type===',')){
          out.push({type:'num', v:0});
        }
        while(stack.length){
          const top=stack[stack.length-1];
          if(!(top.type in OPS)) break;
          const o1=OPS[t.type], o2=OPS[top.type];
          if((o1.a==='L' && o1.p<=o2.p) || (o1.a==='R' && o1.p<o2.p)) out.push(stack.pop()); else break;
        }
        stack.push(t);
      }
      else if(t.type==='('){ stack.push(t); }
      else if(t.type===')'){
        while(stack.length && stack[stack.length-1].type!=='(') out.push(stack.pop());
        if(!stack.length) throw new Error('Unmatched )');
        stack.pop();
        if(stack.length && stack[stack.length-1].type==='fun') out.push(stack.pop());
      }
      prev=t;
    }
    while(stack.length){
      const t=stack.pop(); if(t.type==='('||t.type===')') throw new Error('Unmatched ('); out.push(t);
    }
    return out;
  }

  // compile returns a function (x, env) => number  (env holds user variables)
  function compile(expr){
    const rpn = toRPN(tokenize(expr));
    return function(x, env = {}){
      const st=[];
      for(const t of rpn){
        if(t.type==='num') st.push(t.v);
        else if(t.type==='var'){
          if(t.v==='x') st.push(x);
          else if(Object.prototype.hasOwnProperty.call(env, t.v)) st.push(env[t.v]);
          else throw new Error('Undefined variable: '+t.v);
        }
        else if(t.type in OPS){ const b=st.pop(), a=st.pop(); st.push(OPS[t.type].f(a,b)); }
        else if(t.type==='fun'){ const a=st.pop(); st.push(FUN[t.v](a)); }
        else throw new Error('Bad RPN token');
      }
      if(st.length!==1) throw new Error('Eval error');
      return st[0];
    }
  }

  // --- UI + plotting ---
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const fxArea = document.getElementById('fx');
  const scaleInput = document.getElementById('scale');
  const scaleLabel = document.getElementById('scaleLabel');
  const errEl = document.getElementById('err');
  const autoUpdate = document.getElementById('autoUpdate');
  const runBtn = document.getElementById('runTests');
  const testlog = document.getElementById('testlog');
  const clickAdd = document.getElementById('clickAdd');

  // Right sliders panel
  const varPanel = document.getElementById('varPanel');
  const varList  = document.getElementById('varList');

  let scale = 40;            // px per unit (validated)
  let origin = { x: 0, y: 0 };
  let dragging = false; let dragStart = { x:0, y:0, ox:0, oy:0 };

  // Slider state (overrides)
  const varOverrides = Object.create(null);
  let lastVarKeysSig = '';

  // Robust step
  function niceStep(target){
    const t = toFiniteNumber(target, 1);
    if (!(t > 0)) return 1;
    const exp = Math.floor(Math.log10(t));
    const base = t / (10 ** exp);
    let niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
    const step = niceBase * (10 ** exp);
    return (Number.isFinite(step) && step > 0) ? step : 1;
  }
  function formatTick(value, step){
    const s = toFiniteNumber(step, 1);
    const d = Math.max(0, Math.min(8, -Math.floor(Math.log10(s))+1));
    let out = toFiniteNumber(value, 0).toFixed(d);
    if (out.includes('.')) { out = out.replace(/0+$/, ''); if (out.endsWith('.')) out = out.slice(0,-1); }
    return out;
  }

  function drawGridAxes(w,h){
    ctx.lineWidth = 1;

    const sx = toFiniteNumber(scale, 40);
    const xSpan = (w / sx) || 1;
    const ySpan = (h / sx) || 1;
    let step  = niceStep(Math.min(xSpan, ySpan) / 10);
    if (!(step > 0)) step = 1;

    // Grid
    ctx.strokeStyle = '#1a1a1a';
    for (let x = Math.ceil(-origin.x/sx/step)*step; x < (w-origin.x)/sx; x += step) {
      const gx = origin.x + x*sx; ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
    }
    for (let y = Math.ceil((origin.y-h)/sx/step)*step; y < origin.y/sx; y += step) {
      const gy = origin.y - y*sx; ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = '#6b6b6b';
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h); ctx.stroke();

    // Tick labels
    ctx.fillStyle = '#a3a3a3'; ctx.font = '12px system-ui';
    for (let x = Math.ceil(-origin.x/sx/step)*step; x < (w-origin.x)/sx; x += step) {
      if (Math.abs(x) < 1e-9) continue; const gx = origin.x + x*sx; ctx.fillText(formatTick(x, step), gx+2, origin.y+12);
    }
    for (let y = Math.ceil((origin.y-h)/sx/step)*step; y < origin.y/sx; y += step) {
      if (Math.abs(y) < 1e-9) continue; const gy = origin.y - y*sx; ctx.fillText(formatTick(y, step), origin.x+6, gy-2);
    }
  }

  function plot(fn, w, h, color, env){
    ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.beginPath();
    const sx = toFiniteNumber(scale, 40);
    const step = 1/sx; let first=true;
    const xMin = -origin.x/sx, xMax = (w-origin.x)/sx;
    for(let x=xMin; x<=xMax; x+=step){
      let y = fn(x, env); if(!Number.isFinite(y)){ first=true; continue; }
      const px = origin.x + x*sx; const py = origin.y - y*sx;
      if(first){ ctx.moveTo(px,py); first=false; } else { ctx.lineTo(px,py); }
    }
    ctx.stroke();
  }

  // Parse the single box into vars + functions + points
  function splitBox(text){
    const fns = [];
    const pts = [];
    const vars = {};
    const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);

    const varRe = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)$/i;
    const ptRe  = /^\(?\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*,\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*\)?$/i;
    const defHead = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*x\s*\)\s*=\s*/i;

    for(let raw of lines){
      const line = raw.replace(defHead,''); // drop f(x)= if present

      const mv = varRe.exec(line);
      if(mv){ vars[mv[1]] = parseFloat(mv[2]); continue; }

      const mp = ptRe.exec(line);
      if(mp){ pts.push({ x:parseFloat(mp[1]), y:parseFloat(mp[2]) }); continue; }

      fns.push(line);
    }
    return { fns, pts, vars };
  }

  function drawPoints(w,h, pts){
    ctx.lineWidth = 1.5;
    for(const p of pts){
      const px = origin.x + p.x*scale;
      const py = origin.y - p.y*scale;
      ctx.beginPath();
      ctx.arc(px, py, Math.max(2, 4), 0, Math.PI*2);
      ctx.fillStyle = '#e6e6e6';
      ctx.strokeStyle = '#6b6b6b';
      ctx.fill(); ctx.stroke();
    }
  }

  // Build/update variable sliders on the right
  function guessRangeFor(v){
    const a = Math.abs(v);
    if (a >= 1){
      const r = a * 2;
      return { min: -r, max: +r, step: +(r/100).toPrecision(2) };
    }
    return { min: -10, max: 10, step: 0.1 };
  }

  function ensureVarControls(varsFromText){
    const keys = Object.keys(varsFromText).sort();
    const sig = keys.join(',');
    if (sig === lastVarKeysSig) return; // no change, keep as-is

    // Rebuild panel
    lastVarKeysSig = sig;
    varList.innerHTML = '';
    varPanel.hidden = keys.length === 0;

    keys.forEach(name=>{
      const initVal = toFiniteNumber(
        varOverrides[name] !== undefined ? varOverrides[name] : varsFromText[name],
        0
      );
      const { min, max, step } = guessRangeFor(initVal);

      const row = document.createElement('div');
      row.className = 'varRow';
      row.innerHTML = `
        <label for="var_${name}">
          <strong>${name}</strong>
          <small id="lbl_${name}">${initVal}</small>
        </label>
        <input id="var_${name}" type="range" min="${min}" max="${max}" step="${step}" value="${initVal}" />
      `;
      varList.appendChild(row);

      const slider = row.querySelector(`#var_${name}`);
      const label  = row.querySelector(`#lbl_${name}`);

      slider.addEventListener('input', ()=>{
        const v = toFiniteNumber(slider.value, initVal);
        varOverrides[name] = v;
        label.textContent = v;
        if (autoUpdate.checked) render();
      });
    });
  }

  function mergedEnv(varsFromText){
    // Slider overrides win; fallback to text value
    const env = { ...varsFromText };
    for (const k in varOverrides){
      env[k] = varOverrides[k];
    }
    return env;
  }

  function safeCanvasSize(){
    const dpr = toFiniteNumber(window.devicePixelRatio, 1) || 1;
    let w = Math.max(1, Math.floor(c.clientWidth * dpr));
    let h = Math.max(1, Math.floor(c.clientHeight * dpr));
    return { w, h, dpr };
  }

  function render(){
    try{
      // validate scale
      scale = clamp(Math.round(toFiniteNumber(scale, 40)), 5, 2000);
      scaleInput.value = String(scale);
      scaleLabel.textContent = scale + ' px/unit';

      const { w, h } = safeCanvasSize();
      if (c.width!==w || c.height!==h){ c.width=w; c.height=h; }

      // Background
      ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,w,h);

      // Grid & axes
      drawGridAxes(w,h);

      // Read box
      errEl.textContent = '';
      const { fns, pts, vars } = splitBox(fxArea.value);

      // Build/update sliders if var set changed
      ensureVarControls(vars);

      // Env with overrides applied
      const env = mergedEnv(vars);

      // Draw functions (safe HSL; fallback hex)
      const hues = [0,30,60,120,180,210,240,270,300];
      const fallback = ['#ff6b6b','#ffd166','#06d6a0','#4cc9f0','#a78bfa','#f472b6','#f59e0b','#22c55e','#60a5fa'];
      fns.forEach((line,i)=>{
        try{
          const expr = line.replaceAll('−','-'); // normalize minus
          const fn = compile(expr);
          let color = `hsl(${hues[i % hues.length]}, 75%, 55%)`;
          try { ctx.strokeStyle = color; } catch { color = fallback[i % fallback.length]; }
          plot(fn, w, h, color, env);
        }catch(e){ errEl.textContent += (errEl.textContent?'\n':'') + 'Fn error: ' + String(e?.message||e); }
      });

      // Points
      drawPoints(w,h, pts);
    }catch(e){
      errEl.textContent = 'Render error: ' + String(e?.message || e);
      console.error(e);
    }
  }

  // center origin initially
  function centerOrigin(){
    const { w, h } = safeCanvasSize();
    origin.x = w/2; origin.y = h/2;
  }
  centerOrigin();

  // UI bindings
  scaleInput.addEventListener('input', ()=>{
    const val = toFiniteNumber(scaleInput.value, 40);
    scale = clamp(Math.round(val), 5, 2000);
    scaleLabel.textContent = scale+' px/unit';
    render();
  });

  document.getElementById('resetFns').addEventListener('click', ()=>{
    fxArea.value = '';
    // clearing text also clears overrides and sliders
    for (const k in varOverrides) delete varOverrides[k];
    lastVarKeysSig = '';
    render();
  });

  document.getElementById('resetView').addEventListener('click', ()=>{
    scale = 40; scaleInput.value = '40'; scaleLabel.textContent='40 px/unit';
    centerOrigin(); render();
  });

  // Click-to-add points (appends a new (x,y) line to the single box)
  c.addEventListener('click', (e)=>{
    if(!document.getElementById('clickAdd').checked) return;
    const rect = c.getBoundingClientRect();
    const { dpr } = safeCanvasSize();
    const sx = (e.clientX - rect.left) * dpr;
    const sy = (e.clientY - rect.top) * dpr;
    const x = (sx - origin.x) / scale;
    const y = (origin.y - sy) / scale;
    const line = `(${x.toFixed(3)},${y.toFixed(3)})`;
    fxArea.value += (fxArea.value.trim() ? '\n' : '') + line;
    render();
  });

  // live update when typing
  fxArea.addEventListener('input', ()=>{ if(autoUpdate.checked) render(); });

  // interactions
  c.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const s = Math.sign(e.deltaY) || 1;
    const prev = scale;
    const next = clamp(Math.round(prev * (s>0 ? 0.9 : 1.1)), 5, 2000);
    if(next !== prev){
      scale = next;
      scaleInput.value = String(scale);
      scaleLabel.textContent = scale+' px/unit';
      render();
    }
  }, {passive:false});

  c.addEventListener('mousedown', (e)=>{ dragging=true; dragStart={ x:e.clientX, y:e.clientY, ox:origin.x, oy:origin.y }; });
  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    const { dpr } = safeCanvasSize();
    origin.x = dragStart.ox + (e.clientX - dragStart.x) * dpr;
    origin.y = dragStart.oy + (e.clientY - dragStart.y) * dpr;
    render();
  });
  window.addEventListener('mouseup', ()=>{ dragging=false; });

  // resize-aware
  const ro = new ResizeObserver(()=>{ centerOrigin(); render(); }); ro.observe(c);

  // --- Self tests (includes variable support) ---
  runBtn.addEventListener('click', runTests);
  function approx(a,b,eps=1e-9){ return Math.abs(a-b) <= eps; }
  function line(msg, ok){ return `${ok?'✅':'❌'} ${msg}`; }
  function runTests(){
    const tests = [];
    try{
      const f1 = compile('x^2'); tests.push(line('x^2 at x=3 => 9', approx(f1(3),9)));
      const f2 = compile('sin(x)'); tests.push(line('sin(0) => 0', approx(f2(0),0)));
      const f3 = compile('x^3-3*x'); tests.push(line('x^3-3*x at x=2 => 2', approx(f3(2),2)));
      const f4 = compile('sqrt(abs(x))'); tests.push(line('sqrt(abs(-9)) => 3', approx(f4(-9),3)));
      const f5 = compile('exp(-x^2)'); tests.push(line('exp(-x^2) at x=0 => 1', approx(f5(0),1)));
      const f6 = compile('log(E)'); tests.push(line('log(E) => 1', approx(f6(0),1)));
      const f7 = compile('-x'); tests.push(line('unary minus: -x at x=5 => -5', approx(f7(5),-5)));
      const f8 = compile('sin(PI/2)'); tests.push(line('sin(PI/2) => 1', approx(f8(0),1)));
      const f9 = compile('ln(E^2)'); tests.push(line('ln(E^2) => 2', approx(f9(0),2)));
      const fv1 = compile('a*x + 2'); tests.push(line('a*x+2 with a=3, x=4 => 14', approx(fv1(4,{a:3}),14)));
      const fv2 = compile('b^2 + x'); tests.push(line('b^2+x with b=-2, x=1 => 5', approx(fv2(1,{b:-2}),5)));
      testlog.textContent = `${tests.join('\n')}\n\n${tests.every(t=>t.startsWith('✅'))?'All passed.':'Some failed.'}`;
    }catch(e){ testlog.textContent = 'Test crashed: '+(e?.message||e); }
  }

  // initial paint (blank)
  render();
</script>
</body>
</html>
